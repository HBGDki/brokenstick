---
title: "Validating broken stick model"
author: "Stef van Buuren (for Craig Anderson)"
date: "7 februari 2016"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Objective

This vignette shows how to predict observations by the broken stick model, and validate it against a holdout sample.

## Preliminaries

The `brokenstick` package contains functions to fit and predict the broken stick model. If you have been marked as a collaborator on GitHub, generated a personal access token (PAT) on <https://github.com/settings/tokens>, and stored your PAT by `Sys.setenv(GITHUB_PAT = "51he..")`, then install the `brokenstick` package from GitHub as follows: 

```{r eval = FALSE}
install.packages("devtools")
devtools::install_github(repo = "stefvanbuuren/brokenstick", oath = Sys.getenv("GITHUB_PAT"))
```

Alternatively, install from the package source by

```{r eval = FALSE}
install.packages(pkgs, repos = NULL, type = "source")
```

where `pkgs` is the name of the package sources, e.g., `pkgs = "myproject\brokenstick_0.16.tar.gz"`.

We will use the `cpp` demo data taken from the `hbgd` package. For installing this package use:

```{r eval = FALSE}
options(repos = c(tessera = "http://packages.tessera.io", getOption("repos")))
install.packages("hbgd")
```

## Demo data

We will use the `smocc.hgtwgt` demo data taken from the `brokenstick` package. 

```{r}
library("brokenstick")
head(smocc.hgtwgt)
```

Here is Craig's definition of the `holdout` function:

```{r}
holdout <- function(data, random=TRUE){
  
  colnames(data)[1:3] <- c("ID", "age", "y")
  
  ID <- data$ID
  row <- 1:nrow(data)
  
  
  samplerandom <- function(x){
    if(length(x)==1){
      0
    }else{
      sample(x,1) 
    }
  }
  
  samplemax <- function(x){
    if(length(x)==1){
      0
    }else{
      max(x)
    }
  }
  
  
  if(random==TRUE){
    validation.set <- tapply(X=row,INDEX=ID,FUN=samplerandom)
  }else{
    if(random==FALSE){
      validation.set <- tapply(X=row,INDEX=ID,FUN=samplemax)
    }
  }
  
  hold <- row %in% validation.set
  
  return(hold)
}
```

We take height of the first 2000 observations of the `smocc.hgtwgt` data, where the height - according to advice - is modeled in the Z-score scale:

```{r}
data <- smocc.hgtwgt[1:2000, c("id", "age", "hgt.z", "hgt", "sex")]

# generate random holdout sample
set.seed(63621)
data <- data.frame(data, hold = holdout(data))
head(data)
summary(data)
```

## Prediction with broken stick model

Here's the first part code of Craig's `brokenstickhold.R` function (slightly adapted):

```{r}
  #Rename columns of data matrix
  colnames(data) <- c("id", "age", "y", "hgt", "sex", "hold")
  
  UID <- unique(data$id)

  # instead of uniform knots: knots=c(0.2, 0.4, 0.6, 0.8)
  # take four internal knots at 20th, 40th, 60th and 80th age quantile
  knots <- quantile(data$age, seq(0, 0.8, 0.2))
  knots
  
  #Separate retained and removed data
  data.fit <- data[data$hold==FALSE,]
  data.pred <- data[data$hold==TRUE,]
  
  mod <- brokenstick(y=data.fit$y,
                     x=data.fit$age,
                     subject=data.fit$id,
                     storeX=T,
                     knots=knots,
                     Boundary.knots = c(
                       min(data.fit$age, na.rm = TRUE),
                       max(data.fit$age, na.rm = TRUE)))
  mod
```

## Validation plots

Let's take the first child. Predicting the broken stick at the break ages is done as:

```{r}
  a <- data[data$id==UID[1],]
  b <- predict(mod, a$y, a$age)

  plot(x = a$age, y = a$y, type = "b")
  brk <- c(mod@knots, mod@Boundary.knots[2])
  brk
  lines(x = brk, y = b, col = "red", lwd = 2, lty = 2, type = "b")
  abline(v = brk, lty = 5, col = "grey80")
```

Now let's find the predicted value at each observation. Note: This requires *brokenstick 0.16*, which incorporates the new `type = "response"` argument. 

```{r}
  a <- data[data$id==UID[1],]
  b <- predict(mod, a$y, a$age, type = "response")

  plot(x = a$age, y = a$y, type = "b")
  points(x = a$age, y = b, col = "red", lwd = 2, lty = 2, type = "b")
  abline(v = a$age, lty = 5, col = "grey80")
```

Let's now obtain the predicted values of all children (there should be more elegant ways of doing this, but `lapply()` does not not properly dispatch to `predict()`).

```{r fig.height=7, fig.width=7}
  ## predict for all data
  ds <- split(data, f = data$id)
  result <- vector("list", length(ds))

  for (i in 1:length(ds)) {
    d <- ds[[i]]
    if (nrow(d) > 0) result[[i]] <- predict(mod, d$y, d$age, type = "response")
  }

  data$zhat <- unlist(result)
  
  library("MASS")
  eqscplot(x = data$zhat, y = data$y, xlab = "Predicted Z-score", ylab = "Observed Z-score", main = "All children") 
  abline(0, 1, col = "blue")
```

## Convert to original scale

We have done all modeling in the Z-score scale, so our models can remain simple. If we want the result in the cm scale, we must convert the estimates using the WHO reference, as follows:

```{r fig.height=7, fig.width=7}
# convert Z-score to CM
library("AGD")   # get AGD 0.35 from CRAN 

data$yhat <- z2y(z = data$zhat, 
                 x = data$age,
                 sex = ifelse(data$sex == "female", "F", "M"),
                 ref = get("who.hgt", pos = "package:AGD"))

eqscplot(x = data$yhat, y = data$hgt, xlab = "Predicted (cm)", 
     ylab = "Observed (cm)", main = "All children")
abline(0, 1, col = "blue")
```

Are the test and validation samples different?

```{r}
library(lattice)
xyplot(hgt ~ yhat | hold, data = data, xlab = "Predicted (cm)", 
     ylab = "Observed (cm)", main = "All children", aspect = "iso")
```

## Some advice

Please adapt for your own purposes, but take the following into account:

1. Keep the number of knots low (for speed). If you want to predict at specific time points, then specify those time points as knot locations;
2. The practically interesting scenario is predicting into the future using the historic information. The broken stick model can do this, and is - I believe - particularly useful for doing just that;
3. Specify the first break point `knot[1]` equal to `Boundary.knots[1]` and equal to the minumum age, otherwise unpredictable things occur. I hope to remove this limitation in the future;
4. Although the broken stick model can also fit observations in the cm-scale, it is **much better** to fit to the measurements in the **Z-score scale**, and convert back to cm-scale afterwards when needed. Use the `AGD` package (from CRAN) or the `hbgd` package to convert back and forth;
5. Predictions should ideally be evaluated with respect to the width and coverage of the prediction interval. The current version does not provide prediction intervals. The theory can probably be taken from the Skondral paper, and the package will need to do be extended with additional functions.

Hope this helps.
