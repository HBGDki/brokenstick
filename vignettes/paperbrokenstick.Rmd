---
title: 'Raster growth curves through the broken stick model'
author: "Stef van Buuren"
date: '`r Sys.Date()`'
output:
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
  html_document:
    keep_md: yes
fontsize: 12pt
documentclass: article
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
```


```{r loadlattice, echo = FALSE, warn.conflicts = FALSE, quietly = TRUE}
library("lattice")
trellis.par.set(strip.background = list(col="grey95"))
```

# Introduction

<!-- Growth curve data are collected for a variety of reasons: to monitor the growth of an individual child over time, to determine when growth is abnormal and take appropriate action, to identify critical periods where lack of growth contributes disproportionally to the genesis of a later health problem, and to predict future course of the individual growth trajectory under various potential treatments. -->

Growth curves are collected to monitor the growth of an individual child over time, to determine when growth is abnormal and take appropriate action, to identify critical periods where lack of growth contributes disproportionally to the genesis of a later health problem, and to predict future course of the individual growth trajectory under various potential treatments.

A major problem in quantitative analysis of growth curves is the irregular nature of the number and timing of measurements. Many processes lead to the formation of irregularly spaced longitudinal data: a person may have missed one or more visits, or may have dropped out alltogether, data from multiple centres are combined but have dissimilar visiting schedules, weekends or holidays prohibit taking measurements, or the timing of the measurements left fully up to the person. 

The problem of irregularly spaced time series is well known in disciplines like astronomy, finance, turbulence research and the geosciences. Various methods surfaced for transforming such data into equally spaced series, typically applying some form of linear interpolation, binning, rolling or modeling. Transforming data in such a way is known to have drawbacks. Most approaches implicitly reduce the series to a single deterministic value, and thus ignore the stochasticity of the process. This leads to significant overestimate of autocorrelations and underestimate of the crosscorrelations, especially if the spacing of observations is highly irregular.[@rehfeld2011]

```{r visits, echo = FALSE, fig.cap="Ages at which 25 children visited the youth health care. Scheduled times are indicated by grey lines. SMOCC data."}
require("brokenstick")
data <- smocc.hgtwgt
dotplot(id ~ age, data = data[1:243,], groups = rec, pch = "|", col = "blue", xlab = "Age (in years)", 
        	   panel = function(...) { 
	   	panel.refline(v = c(0, 0.0767, 0.1533, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 2))
	   	panel.dotplot(...)
	   }
)

```

Many data from the social and biomedical sciences are longitudinal, where multiple persons are measurement on multiple time points that may differ between persons. The latter complicates the construction of columns that collect the data of all persons measures at the time point. Figure 1 demonstrates the variability in ages at which 25 children from the SMOCC study [@herngreen1994] visited a Dutch youth health care center. While the planned visiting schedule is easy to recognize, the ages at which children come can vary, and especially so when they get older.  This complicates, for example, calculating the correlation in height at different ages.

A popular approach to deal with unbalanced data is the linear mixed model[@fitzmaurice2011]. The mixed model summarizes individual trajectories by a small number of parameters, the random effects, that vary over subjects. The distribution of these random effects are then analyzed to answer the questions of scientific interest. Linear mixed effect models are attractive because of their flexibility in accomodating for imbalance in longitudinal data. These models work well when the number of observations on each individual differs, or when the measurements are taken at different times.

This paper focusses on one particular linear mixed model, the *broken stick model*, in the context of fitting individual growth curves. The broken stick model represents each individual growth trajectory by a second order B-spline, so that each fitted curve becomes a series of straight lines that connect at specified break ages. The model can be used

- to smooth individual growth curves by a series of connected straight lines;
- to align irregularly observed curves to a common age grid;
<!-- - to draw realizations of individual trajectories at given break ages; -->
- to estimate the time-to-time correlation matrix;
- to predict future observations.

The user needs to specify the set of break ages at which the straight lines connect. Each child obtains an estimate of its conditional mean at each break age, so the set of estimates of the child form a smoothed and regularized version of the observed trajectory. 

The main assumptions of the broken stick model are twofold. First, the child trajectory between the break ages follows a straight line, and is generally not of particular scientific or clinical interest. Second, conditional mean estimates, or *broken stick estimates*, follow a common multivariate normal distribution. 
<!-- In order to conform to the latter assumption, the user may fit the broken stick model on suitably transformed data that yield the standard normal ($Z$) scale.  -->

This paper describes the broken stick model, and highlights various computational tools from the `brokenstick` package. The package can be used to fit the broken stick model to data, to export the parameters of the fitted model for use outside the package, to create imputed values of the model, and to predict broken stick estimates for new data. In addition, we illustrate the use of the package to solve various analytic problems. 

# Method

## Notation

We adopt the notation of @fitzmaurice2011. Let $Y_{ij}$ denote the response variable for the $i^{\rm th}$ subject on the $j^{\rm th}$ measurement occasion at time $t_{ij}$. Data are collected in a sample of $N$ persons $i=1,\dots,N$. Let repeated measurements for the $i^{\rm th}$ subject are grouped as 
\[ Y_i = \left( \begin{array} {l} Y_{i1} \\ Y_{i2} \\ \vdots \\ Y_{in_i} \end{array} \right), \quad i = 1, \dots, N.\]
If the measures have been observed at a common same set of occasions, then we could drop the index $i$ in $t_{ij}$ since $t_{ij} = t_j$ for all $i = 1, \dots, N$. Here we will focus on the case that $t_{ij}$ varies over $i$. In addition, let use define the $n_i \times p$ matrices
\[ X_i = \left( \begin{array} {llll} 
 X_{i11} & X_{i12} & \cdots & X_{i1p} \\
 X_{i21} & X_{i22} & \cdots & X_{i2p} \\
 \vdots  & \vdots  & \ddots & \vdots  \\
 X_{in_i1} & X_{in_i2} & \cdots & X_{in_ip}
\end{array} \right), \quad i = 1, \dots, N,\]
so that the rows of $X_i$ contain covariates associated with the responses at $n_i$ measurement occasions. The columns correspond to $p$ different covariates, which may be time-varying covariates. If a certain covariate is fixed in time (e.g. sex, treatment, education), then all within the corresponding column in $X_i$ are identical.

## Broken stick model

We avoid modeling observation times $t_{ij}$ directly by representing each $t_{ij}$ as its relative position within a time interval. For example, suppose $t_{ij} = 0.6$ years and that the time interval is given by 0.5-1.0 years. The position relative to the left break age is $x_{\rm left} = (1.0-0.6)/(1.0-0.5) = 0.8$, whereas relative to the right break age is $x_{\rm right} = (0.6-0.5)/(1.0-0.5) = 0.2$. In order to fit the broken stick model, we need to replace time point $t_{ij} = 0.6$ by two values: 0.8 (for break age 0.5), and 0.2 (for break age 1.0). Note that both values add up to 1. Coding time in this way simplifies modeling continuous time by a set of discrete break ages.

More specifically, let $t_{ij}$ be coded by a second order (linear) B-spline using $k$ internal knots placed at $k$ ordered ages
$$
\kappa_0 = \kappa_1 < \dots < \kappa_k < \kappa_{k+1}
$$
The internal knots $\kappa_1, \dots, \kappa_k$ correspond to the set of ages for which we obtain broken stick estimates, and it should preferably be specified by the user. The left boundary knot $\kappa_0 = \kappa_1$ is conveniently set to the minimum age $\min(t_{ij})$ in the data, whereas the right hand boundary knot $\kappa_{k+1} \geq \max(t_{ij})$. 

The second order B-spline [@deboor1978 pp. 32],
$$
H_s(t) = \left\{ \begin{array} {l@{\quad,\quad}l}
(t-\kappa_{s-1})/(\kappa_s - \kappa_{s-1}) & \kappa_{s-1} < t \leq \kappa_s,\\
(\kappa_{s+1}-t)/(\kappa_{s+1} - \kappa_s) & \kappa_s \leq t < \kappa_{s+1},\\
0 & {\rm otherwise.}
\end{array} \right. 
$$
is applied to $t_{ij}$ to obtain $(k+1)$ transformed variables $x_{is} = t_{ij}$ with $s = 1,\dots,k+1$. These variables can conveniently be grouped into the $n_i \times (k+1)$ matrix of covariates $X_i = (x_{i1}, \dots, x_{ik}, x_{i(k+1)})$. Each row in $X_i$ has only one or two non-zero elements, which sum to 1.

Using this $X_i$, the broken stick model is a special case (with $Z_i = X_i$) of the two-stage random-effects model [@laird1982]

$$
Y_i = X_i\beta + X_ib_i + \epsilon_i
$$

where the $k+1$ column vector $\beta$ contains $k+1$ fixed effect coefficients common to all persons, where the $k+1$ column vector $b_i$ accomodates for $k+1$ subject-specific random parameters, and where the $n_i$ column vector $\epsilon_i$ holds subject-specific residuals. 

In order to complete the model specification, we assume that the residuals are identically and independently distributed as $\epsilon_i \sim N(0,\sigma^2 I(n_i))$, where $\sigma^2$ is a common variance parameter, and where $I(n_i)$ is the identity matrix. Thus, the equation represents population parameters (fixed effects), individual effects (random effects), and an amount of within-person dispersion that is the same for all persons.

At the person level, we assume $b_i \sim N(0, \Omega)$, i.e., the random coefficients of the subjects have a multivariate normal distribution with zero mean and a $(k+1) \times (k+1)$ covariance matrix $\Omega$. In addition, we assume that the covariance between $b_i$ and $\epsilon_i$ is zero.

In summary, given the knot specification and the choice of the response scale, the parameters of the broken stick model are:

- $\beta$, a vector of $k + 1$ fixed parameters;
- $\Omega$, a $(k+1) \times (k+1)$ covariance matrix of the random effects;
- $\sigma^2$, the within-person error variance.

The total number of parameters for a solution with $k$ internal knots is thus equal to $(k^2 + 5k + 6)/2$. For example, a model of $k = 3$ knots (i.e. with two connected lines) has 15 parameters, a model with $k = 4$ has 21 parameters, and a model with $k = 10$ break ages has 78 parameters. 

## Interpretation

Interpretation of the broken stick model is as follows. The sum $\gamma_{is} = \beta_s + b_{is}$ is the *conditional* (or subject-specific) mean of $Y_i$ at age $\kappa_s$, $s = 1,\dots, k$. The set of $\gamma_{is}$ parameters describes the mean response profile for any individual as $k-1$ lines that connect at the $k$ coordinates $(\kappa_k, \gamma_{is})$. The model thus effectively represents the $n_i$ measurements of subject $i$ by $k$ new points. The analysis of the $k$ data points at ages $\kappa$ is generally easier than the analysis of $n_i$ values when $t_{ij}$ differs across persons. If $n_i >> k$ then the broken stick model provides a parsimonious representation of the measurements. Reversely, if $n_i << k$ then the model infers plausible values for subject $i$ by building strength across persons. The major advantage of the broken stick model is that converts $n_i$ irregularly observed measurements into a new set of $k$ values $\gamma_{is}$ at common times $\kappa_1, ..., \kappa_k$, $s = 1,\dots, k$.

Since each row in $X_i$ sums to unity, the broken stick model does not have an intercept term. The linear B-spline coding effectively replaces the conventional random intercept term by $k$ *local intercepts*, one at each break age. The local intercept summarizes the information available in the adjacent left and right age intervals, and ignores any information beyond the adjacent knots. The broken stick estimates are primarily local estimates. Data beyond the adjacent age intervals influence broken stick estimates only through the subject-level part of the model.


# Model fitting

## Data

The `brokenstick` R package implements various function that assist in fitting and displaying the broken stick model. The package has a built-in dataset, called `smocc.hgtwgt`, with example data.

```{r loadpackage}
require("brokenstick")
data <- smocc.hgtwgt
head(data)
```

The dataset has `r nrow(data)` rows, with longitudinal heights and weights of `r length(unique(data$id))` unique infants during their first two years of life. 

The next code draws the length curves of children 10001 and 10005 by the `lattice` function `xyplot()`, as follows:

```{r loadlattice2, eval=FALSE, echo=TRUE}
library("lattice")
```

```{r hgtcm, fig.height = 4, fig.cap="Length curve (in cm) of two children."}
xyplot(hgt ~ age | id, data = data, 
	   subset = id %in% c(10001, 10005), 
	   type = "b", pch = 19, as.table = TRUE)
```

The representation in Figure \@ref(fig:hgtcm) show that length increase with age. 

Figure \@ref(fig:hgtz) shows a plot of the same data with more resolution. It is obtained by calculating the length as a Standard Deviation Scores (SDS), or $Z$-scale. The column `hgt.z` contains the $Z$-scores of child length relative to the WHO Child Growth Standard [@deonis2006].

```{r hgtz, fig.height = 4, fig.cap="Length curve (in SDS) of same two children."}
xyplot(hgt.z ~ age | id, data = data, 
	   subset = id %in% c(10001, 10005), 
	   type = "b", pch = 19, as.table = TRUE,
	   panel = function(...) { 
	   	panel.refline(h = c(-2, 0, 2))
	   	panel.xyplot(...)
	   }
)
```

## Model with three break ages

The broken stick model aims to describe all growth curves in the SMOCC data by a series of straight but connected lines. Let us first do a rough approximation of the data presented in Figure \@ref(fig:hgtz) by chosen three break ages: birth, one year and two years. Thus, one line  starts at birth and ends at one year, and another spans the period from one to two years. The lines connect at the age of one year. 

```{r fit1}
fit1 <- brokenstick(y = data$hgt.z, 
					x = data$age,
					subject = data$id,
					knots = 0:2)
est <- conditional.means(fit1)
head(est)
```

The `brokenstick()` function estimates the parameters of the broken stick model. Behind the screens the method uses the `lmer()` function from the `lme4` package to do the heavy lifting. The break ages are provides by the `knots` argument. The `conditional.means()` function converts the object returned by the `brokenstick()` function into conditional mean estimates at the individual level as explained in section 2. The figure below jointly plots the original data and the broken stick (conditional mean) estimates.

```{r fit1fig, fig.height = 4, echo = FALSE}
library("dplyr", warn.conflicts = FALSE, quietly = TRUE)
colnames(est)[length(colnames(est))] <- "hgt.z"
est <- data.frame(est, src = "smocc", bse = TRUE)
data2 <- bind_rows(data.frame(data, bse = FALSE), est)

xyplot(hgt.z ~ age | id, data = data2,
       groups = bse, 
	     subset = id %in% c(10001, 10005) & age <= 2.3, 
	   type = "b", pch = 19, as.table = TRUE,
	   panel = function(...) {
	   	panel.refline(h = c(-2, 0, 2))
	   	panel.refline(v = 0:2, lwd = 0.5, lty = 2)
	   	panel.xyplot(...)
	   }
)
```

The proportion of the variance of the outcome explained by the two-line model is

```{r r2fit1}
round(var(fitted(fit1)) / var(data$hgt.z), 3)
```


## Models with more break ages

Although the fit of the model is reasonable well, we can improve upon the above model by adding break ages to the model. Suppose we are interest in refining the fit to the growth pattern during the first year through the addition of an extra knots at, say, 5 months. The three-line model is fitted to all children as    

```{r fit2}
knots <- c(0, 5/12, 1, 2)
fit2 <- brokenstick(y = data$hgt.z, 
					x = data$age,
					subject = data$id,
					knots = knots,
					storeX = TRUE)
```


```{r fit2fig, echo=FALSE, fig.width = 6}
est <- conditional.means(fit2)
colnames(est)[length(colnames(est))] <- "hgt.z"
est <- data.frame(est, src = "smocc", bse = TRUE)
data2 <- bind_rows(data.frame(data, bse = FALSE), est)

xyplot(hgt.z ~ age | id, data = data2,
       groups = bse, 
	     subset = id %in% c(10001, 10005) & age <= 2.3, 
	   type = "b", pch = 19, as.table = TRUE,
	   panel = function(...) {
	   	panel.refline(h = c(-2, 0, 2))
	   	panel.refline(v = knots, lwd = 0.5, lty = 2)
	   	panel.xyplot(...)
	   }
)
```

Figure \@ref(fig:fit2fig) shows the result. The proportion of explained variance is equal to `r round(var(fitted(fit2)) / var(data$hgt.z), 3)`. 

Adding break ages will improve the local fit in the vicinity of the new knot. In general, knot placement should take the scientific context into account, in particular the visiting schedule. In Figure \@ref(fig:visits) the scheduled visits occur at birth (retrospective), at 4 and 8 weeks, and at 3, 6, 9, 12, 15, 18 and 24 months. Since fitting the model with these break ages takes longer, the solution is stored as object `fit.hgt` in the `brokenstick` package. 

```{r echo = FALSE}
est <- conditional.means(fit.hgt)
colnames(est)[length(colnames(est))] <- "hgt.z"
est <- data.frame(est, src = "smocc", bse = TRUE)
data2 <- bind_rows(data.frame(data, bse = FALSE), est)

xyplot(hgt.z ~ age | id, data = data2,
       groups = bse, 
	     subset = id %in% c(10001, 10005) & age <= 2.3, 
	   type = "b", pch = 19, as.table = TRUE,
	   panel = function(...) {
	   	panel.refline(h = c(-2, 0, 2))
	   	panel.refline(v = fit.hgt@knots, lwd = 0.5, lty = 2)
	   	panel.xyplot(...)
	   }
)
```

For the model with 10 break ages, the proporion of explained variance is 

```{r r2fit.hgt}
round(var(fitted(fit.hgt)) / var(data$hgt.z), 3)
```

which is considerably higher than the simpler two and three-line models. Including an extra knot improves model fit, but note that this will also increase the number of parameters to be estimated by $k+2$.

## Export the fitted model

The `fit1` object can be stored by `save()` for future use in R. However, it is a fairly large object that contains a lot of material about the fitted linear mixed model that is not all needed (to see this, use `slotNames(fit1)`). As a matter of fact, prediction using the broken stick model requires the following: knot locations $\kappa$, the fixed effect estimates $\beta$, the variance/covariance matrix of the random effects $\Omega$, and the size of the residual variance $\sigma^2$. The `export.brokenstick()` function collects this information from the fitted model into a list. 

```{R}
# export the broken stick models
export.hgt <- export.brokenstick(fit1)
export.hgt
```


# Prediction

Prediction on new data can be obtained by the `predict()` function. There are two types of prediction, which is controlled by the `type` argument. Calling `brokenstick(..., type = "curve", ...)` (the default) yields a prediction at every break age, including those in the future. Calling `brokenstick(..., age, type = "response", ...)` is more flexible, and yields a prediction at each age specified by `age`. 

## Prediction at break ages, single child

Let us take the first child in the data. Predicting the broken stick values at the break ages for this child can be done from either the `fit.hgt` object (of class `brokenstick`) or the `fit.hgt.exp` object (having class `brokenstick.export`). Here we use `fit.hgt.exp`:

```{r firstsix}
# export built-in length model
fit.exp <- export.brokenstick(fit.hgt)

# child 10001, first six measures only
UID <- unique(data$id)
cid <- UID[1]
d <- data[data$id == cid & data$rec <= 6, ]
b <- predict(fit.exp, d$hgt.z, d$age)

plot(x = d$age, y = d$hgt.z, type = "b", col = "blue", 
     xlab = "Age (yrs)", ylab = "hgt.z", main = paste("Break ages, child", cid),
     xlim = c(0, 2))
brk <- c(fit.exp$knots, fit.exp$Boundary.knots[2])
lines(x = brk, y = b, col = "red", lwd = 1.5, lty = 2, type = "b")
abline(v = brk, lty = 5, col = "grey80")
```


## Prediction at measurement ages, single child

Suppose we want a predicted value at each age at which the child was measured. We need to include the `type = "response"` argument.

```{r}
b <- predict(fit.exp, d$hgt.z, d$age, type = "response")

plot(x = d$age, y = d$hgt.z, type = "b", col = "blue", 
     xlab = "Age (yrs)", ylab = "hgt.z", 
     main = paste("Measurement ages, child", cid), 
     xlim = c(0, 2))
points(x = d$age, y = b, col = "red", 
       lwd = 1.5, lty = 2, type = "b")
abline(v = d$age, lty = 5, col = "grey80")
```


## Prediction at arbitrary ages, single child

Suppose we want the predicted value at the ages of 6, 8, 10, 12, 14, and 24 months. For this, we need to pad the observations of child `r cid` with new ages and with missing outcomes, as follows:

```{r}
age <- c(d$age, c(6, 8, 10, 12, 14, 24)/12)
y <- c(d$hgt.z, rep(NA, 6))
b <- predict(fit.exp, y, age, type = "response")

plot(x = d$age, y = d$hgt.z, type = "b", col = "blue", 
     xlab = "Age (yrs)", ylab = "hgt.z", 
     main = paste("Arbitrary ages, child", cid),
     xlim = c(0, 2))
idx <- -(1:length(d$age))
points(x = age[idx], y = b[idx], col = "red", 
       lwd = 1.5, lty = 2, type = "b")
abline(v = age[idx], lty = 5, col = "grey80")
```


## Predict values, all children

A split and loop can be used to obtain the predicted values of all children in the test data, as follows:

```{r fig.height=7, fig.width=7}
ds <- split(data, f = data$id)
result <- vector("list", length(ds))

for (i in seq_along(ds)) {
  d <- ds[[i]]
  if (nrow(d) > 0) result[[i]] <- predict(fit.exp, d$hgt.z, 
                                          d$age, type = "response")
}

data$zhat <- unlist(result)
```

The scatterplot of the observed versus predicted values indicates a reasonably accurate prediction. The correlation is to `r round(cor(data$zhat, data$hgt.z, use = "all.obs"), 4)`. The standard deviation of the residuals is equal to `r round(sd(data$zhat - data$hgt.z, na.rm = TRUE), 3)`. 

```{r echo=FALSE}
library("MASS")
eqscplot(x = data$zhat, y = data$hgt.z, xlab = "Predicted Z-score", 
         ylab = "Observed Z-score", main = "All children")
abline(0, 1, col = "blue")
```


# Applications

## Realistic growth curve interpolation

### Approaches

Growth references are often visualized by a set of centile curves. Such centiles are convex polygons that are stored with relatively close ages and drawn on a computer by connecting the adjacent vertices by a straight line. The same visualization method is used for plotting individual growth curves, but the connecting measurements by straight lines becomes unrealistic as the data points become less dense in time. 

We discuss two alternative ways to interpolate the data. The first alternative is to apply linear interpolation using the $Z$-scale. This may work well because in the $Z$-scale convexity is not a problem. 

The second alternative is to apply model-based interpolation. We fit a model to the growth trajectory, and predict length at a dense age grid, say a predicted length for each week, and plot the result. The predicted curve represents the most likely values under the model at the intermediate ages, which is a desirable property. On the other hand, realize that at the ages at which the data are observed, the predicted and observed lengths may not coincide. Thus, we have moved from pure interpolation of the measurements to approximation of the data by a model. The upside is that the residual may be informative about the direction and size of measurement errors in the individual data.

### Example

Suppose we measured the length of a boy at the ages of 1 month (52.7 cm) and 14 months (80.5 cm). We use the `AGD` package, available from CRAN, to convert the measurements to standard deviation scores (SDS) relative to the WHO Child Growth Standard. 

```{r zscores, echo=TRUE}
require("AGD")
boy <- data.frame(x = c(1/12, 14/12), y = c(52.7, 80.5))
boy$z <- y2z(y = boy$y, x = boy$x, sex = "M", ref = who.hgt)
boy$z
```


The following block of code computes centiles -2SD through +2SD of the WHO standard for length of boys 0-15 months.

```{r whoref, echo=TRUE}
sds <- c(-2, -1, 0, 1, 2)
age <- round(seq(0, 1.25, 1/48), 3)
z <- rep(sds, times = length(age))
x <- rep(age, each = length(sds))
w <- z2y(z = z, x = x, sex = 'M', ref = who.hgt)
w <- matrix(w, ncol = length(sds), byrow = TRUE)
dimnames(w) <- list(age, sds)
```


```{r fig:inter1, echo = FALSE, fig.cap = "Linear interpolation in the cm scale results in an unrealistic trajectory at intermediate ages."}
oldpar <- par(mfrow = c(1, 2))
matplot(x = as.numeric(rownames(w)), y = w, type = "l", lty = 1, 
        col = "skyblue1", lwd = c(1, 1, 1.5, 1, 1),
        xlab = "Age (years)", ylab = "Length (cm)")
matpoints(x = boy$x, y = boy$y, pch = 20, 
          cex = 1.5, col = "red", type = "o")
v <- matrix(c(c(0, 1.25), rep(-2:2, each = 2)), 
            ncol = 6, byrow = FALSE)
matplot(x = v[,1], y = v[,2:6], 
        type = "l", lty = 1,
        col = "skyblue1", lwd = c(1, 1, 1.5, 1, 1),
        ylim = c(-2.5, 2.5),
        xlab = "Age (years)", ylab = "Length (SDS)")
yout <- approx(x = boy$x, y = boy$y, xout = as.numeric(rownames(w)))$y
zout <- y2z(x = as.numeric(rownames(w)), y = yout, ref = who.hgt)
matpoints(x = boy$x, y = boy$z, pch = 20, 
          cex = 1.5, col = "red", type = "p")
matpoints(x = as.numeric(rownames(w)), y = zout, pch = 20, 
          cex = 1.5, col = "red", type = "l")
```

During the period the boy grows from moderately short (about -1.0 SD at month 1) to moderately tall (about +1.0 SD at month 14). Figure \@ref(fig:inter1) shows the usual representation of the growth curve, where a stright line is drawn between the two measurements. The straight line starts at -1.0 SD, then crosses the -2.0 SD centile around 3 and 6 months, is back at -1.0 SD around 10 months, crosses the 0.0 SD at 12 month, and ends at +1.0 SD at 14 months. Figure right-hand figure portrays the interpolated growth curve in the $Z$ score scale. In practice, finding such a growth pattern is very unlikely since growth in infancy is not linear in time. Hence, the implied representation by interpolation is highly unrealistic. One may try to ameliorate the situation by smoothing the data, but this easilies fails because of sparseness.


```{r fig:inter2, echo = FALSE, fig.cap = "Linear interpolation in the SDS scale results in a more realistic trajectory at intermediate ages."}
oldpar <- par(mfrow = c(1, 2))

zout <- approx(x = boy$x, y = boy$z, xout = as.numeric(rownames(w)))$y
yout <- z2y(x = as.numeric(rownames(w)), z = zout, ref = who.hgt)

matplot(x = as.numeric(rownames(w)), y = w, type = "l", lty = 1, 
        col = "skyblue1", lwd = c(1, 1, 1.5, 1, 1),
        xlab = "Age (years)", ylab = "Length (cm)")
matpoints(x = boy$x, y = boy$y, pch = 20, 
          cex = 1.5, col = "red", type = "p")
matpoints(x = as.numeric(rownames(w)), y = yout, pch = 20, 
          cex = 1.5, col = "red", type = "l")

v <- matrix(c(c(0, 1.25), rep(-2:2, each = 2)), 
            ncol = 6, byrow = FALSE)
matplot(x = v[,1], y = v[,2:6], 
        type = "l", lty = 1,
        col = "skyblue1", lwd = c(1, 1, 1.5, 1, 1),
        ylim = c(-2.5, 2.5),
        xlab = "Age (years)", ylab = "Length (SDS)")
matpoints(x = boy$x, y = boy$z, pch = 20, 
          cex = 1.5, col = "red", type = "p")
matpoints(x = as.numeric(rownames(w)), y = zout, pch = 20, 
          cex = 1.5, col = "red", type = "l")
```

Figure \@ref(fig:inter2) is similar, but performed with interpolation in the $Z$-scale. The resulting representation in the $Y$-scale is more realistic and more pleasing to the eye. The curve crosses the 0 SD line about half way, at about 7.5 months. While this approach is a considerable improvement over interpolation in the $Y$-scale, it is still not ideal. Human growth during the first few months is faster than later in infancy. Because of that, the cross-over point at 7.5 months will - on average - be too late, and should appear earlier.

The following code calculates the broken stick estimates for this problem:

```{r brokenstickinterpolation, echo = TRUE}
# prepare data input
age <- c(boy$x, as.numeric(rownames(w)), fit.exp$knots)
age <- sort(age[age >= age[1] & age <= age[2]])
z <- rep(NA, length(age))
z[1] <- boy$z[1]; z[length(z)] <- boy$z[2]

# predict with broken stick model
zout <- predict(fit.exp, z, age, type = "response")

# convert predicted values to Y-scale
yout <- z2y(x = age, z = zout, ref = who.hgt)
```

```{r fig:inter3, echo = FALSE, fig.cap = "Broken stick model fitted in the SDS scale results in a most realistic expected trajectory at intermediate ages."}
# create the plots
oldpar <- par(mfrow = c(1, 2))
matplot(x = as.numeric(rownames(w)), y = w, type = "l", lty = 1, 
        col = "skyblue1", lwd = c(1, 1, 1.5, 1, 1),
        xlab = "Age (years)", ylab = "Length (cm)")
matpoints(x = boy$x, y = boy$y, pch = 20, 
          cex = 1.5, col = "red", type = "p")
matpoints(x = age, y = yout, pch = 20, 
          cex = 1.5, col = "red", type = "l")

v <- matrix(c(c(0, 1.25), rep(-2:2, each = 2)), 
            ncol = 6, byrow = FALSE)
matplot(x = v[,1], y = v[,2:6], 
        type = "l", lty = 1,
        col = "skyblue1", lwd = c(1, 1, 1.5, 1, 1),
        ylim = c(-2.5, 2.5),
        xlab = "Age (years)", ylab = "Length (SDS)")
matpoints(x = boy$x, y = boy$z, pch = 20, 
          cex = 1.5, col = "red", type = "p")
matpoints(x = age, y = zout, pch = 20, 
          cex = 1.5, col = "red", type = "l")
```

Figure \@ref(fig:inter3) shows the results of the broken stick model. Apart from being too smooth, the predicted curve in the $Y$-scale looks like an individual growth curve. Because growth is faster and more variable during early infancy, most of the growth is realized during that time. As a result, the cross-over point where the predicted value intersect the 0 SD line is now a little below 5 months, considerably earlier than obtained under either interpolation method. Of the three approaches considered here, the broken stick model provides the most realistic expected trajectory at intermediate ages, and hence is a useful candidate for interpolating sparse trajectories.

## Longitudinal growth references

<!-- Time-to-time correlation matrix -->

The broken stick model also provides a handle to estimate the time-to-time correlation matrix of the measurements at the break ages. According to the model, the marginal distribution of $y_i$ is multivariate normal with mean $X_i\beta$ and covariance $X_i\Omega X_i' + \sigma^2 I(n_i)$. 
<!-- In the perfectly fitting case where $\sigma^2 = 0$ and all observations times are at the break ages (so that $X_i$ are identity matrices), then $\Omega$ estimates covariance between raw measurements, but this situation is unlikely to be hold in general. In the more common case that $\sigma^2 > 0$, then $\Omega$ will correctly estimate the covariances among the random effects, but overestimate the covariances between the $y$'s.  -->
The plug-in estimate $\hat\Omega + \hat\sigma^2 I(n_i)$ provides a simple estimate of the covariances between $y$'s at the break ages, which may be transformed into a correlation matrix. The broken stick model can thus be used as a tool to estimate the time-to-time correlation matrix of the measurements had these been done at the break ages.



## Critical periods

Critical periods have been well recognized in human
development. {DIETZ1994} suggested that critical periods may
also exist for obesity.  Dietz defined a critical period for the
development of obesity as ``a developmental stage in which physiologic
alterations increase the later prevalence of obesity'', and suggested
three periods: the prenatal period, the period of adiposity rebound
and adolescence. Obesity that begins at these periods is expected to
increase the risk of persistent obesity and its
complications. Particular complications to consider include
cardiovascular disease, diabetes and loss in bone mineral density.

The question is whether such critical periods can be identified from
empirical cohort data. Starting with the pioneering work of
{BARKER1989}, hundreds of studies have been done. Reviews are
available by {CAMERON2002} and {LLOYD2010}. 

The result of all this activity has been somewhat disappointing. The
Foresight project, a major U.K.~initiative to tackle obesity, says:
``Breastfeeding and early growth patterns provide the only period in
which there is clear evidence to support the concept of a critical
period of development associated with long-term consequences''
[p.~62]{BUTLAND2008}. Furthermore, we find ``It is critical to
note that there is no one point in the life course where intervention
is particularly successful..'' [p.~63]{BUTLAND2008}.
{JOHNSON2006} come to a similar conclusion, and suggest a life cycle
perspective that includes all stages of growth and reproduction.

We find this state of affairs unsatisfactory. If all life phases are a
critical period, then the concept loses its meaning. Another
possibility is that the currently used statistical methodology for
identifying critical periods from longitudinal data is inadequate. A
rigorous quantitative definition of a critical period is lacking. Some
methodological work is available {NAUMOVA2001, KEIJZERVEEN2005,
  DESTAVOLA2006}, but this is not widely known or applied. The
variation in analytic techniques used across studies is large, which
makes it difficult to synthesize the results. Moreover, the timing of
the measurements differs vastly over studies. Of course, we cannot
rule out the possibility that there are no clear critical periods for
overweight.  At this point however, we would keep open the possibility
that such critical methods can be identified if the appropriate
methodology would be used.

There is some indirect evidence that critical periods may indeed be
relevant. {LLOYD2010} challenge the accepted wisdom that
childhood obesity is predictive of later cardiovascular
morbidity. After correcting for adult BMI, they found that the
childhood BMI was not an independent predictor of later health
problems. They suggest that the relation between childhood obesity and
cardiovascular risk is dependent on the tracking of BMI from childhood
to adulthood. In particular, it appears that the risk of raised blood
pressure is highest in those who were of lower BMI in childhood and
overweight in adulthood. This may seem counter-intuitive at first
sight. Realize however that those with the highest risks are also
those who must have had the highest gains in BMI. Thus, it is not the
BMI-level per se that drives the risk, but rather change in BMI
{BARKER2005}. Note that changes may occur at different periods
in life. The theory of Dietz predicts that the same change in BMI
occurring in different periods may have different consequences on
later health.

This paper is an attempt to refine the ideas of Dietz, and formulate
them as a statistical model that can be tested on empirical data. A
practical requirement on the method is that it should work on data with
different measurement ages.





# Discussion

Some unique feature of the broken stick model are:

- *Modular*: Issues related to nonlinearities of the growth curves in the observed scale can be treated separately, i.e., outside the broken stick model. In addition, we may use the broken stick model to pre-process the data, and apply our model of scientific interest to the broken stick estimates;
- *Local*: A given data point will contribute only to the estimates corresponding to the closest break ages;
- *Exportable*: The broken stick model can be exported and reused for prediction for new data in alternative computing environments.

- impute still to do

Modeling advice: Choice of number and locations of knots

However, adding many knots to sparse data will substantially increase calculation time, and result in instable solutions. In general, one should not add more knots than the (average) number of data points per person.

Trick with `storeX` argument.

more knots at periods where one expects substantial change (early infancy, puberty)

- choice of scale (tranformed or Z)

