# brokenstick.R
# 

#' Create linear splines basis 
#' 
#' This function creates the basis function of a linear first-order splines
#' at a user-specific set of break points. The default knots 
#' code the age range 0-3 years.
#' @aliases make.basis
#' @param x a vector of ages at which the basis function are needed
#' @param knots a vector of internal knots
#' @param Boundary.knots vector of external knots
#' @return A matrix with \code{length(x)} rows and \code{length(breaks)}
#' columns, with some extra attributes described by \code{bs()}.
#' @export
make.basis <- function(x, 
                       knots = round(c(0, 28/365.25, 56/365.25, 
                                        1/4, 1/3, 1/2, 7.5/12,
                                        9/12, 11/12, 14/12, 18/12, 2), 4),
                       Boundary.knots = c(0, 3)) {
    # calculate break points 0-2 years as birth + standard visits 0-12 yr
    X <- bs(x, knots = knots, 
            Boundary.knots = Boundary.knots, degree = 1)
    dimnames(X)[[2]] <- paste("x", 0:(ncol(X)-1), sep = "")
    X
}

#' Fit a broken stick model to data
#' 
#' This function fits the 0-3 years broken stick model to 
#' the Z-score of the outcome. This function can be time consuming.
#' @aliases fit.brokenstick
#' @param yvar a string (e.g. \code{"hgt"} or \code{"hgt.z"}) indicating the outcome variable
#' @param data a data frame with the data, including variables \code{x0} through 
#' \code{x12}
#' @return The fitted model of class \code{lmerMod}
#' @examples 
#' library(mice)
#' data <- tbc[tbc$id < 200 & tbc$age < 2.5,]
#' fit <- fit.brokenstick("hgt.z", data)
#' plot(fit)
#' @export
fit.brokenstick <- function(yvar = "hgt.z", data) {
    X <- make.basis(x = data$age)
    d <- cbind(data[c("id", "age", yvar)], X)
    f <- as.formula(paste(yvar, "~", 
                          "0 + ", paste0("x", 0:12, collapse = " + "),
                          "+ (", 
                          "0 + ", paste0("x", 0:12, collapse = " + "),
                          "| id)"))
    fit <- lmer(f, data = d,
                control = lmerControl(check.nobs.vs.nRE = "warning"))
    attr(fit, "knots") <- attr(X, "knots")
    attr(fit, "Boundary.knots") <- attr(X, "Boundary.knots")
    return(fit)
}

#' Obtain broken stick values from a fitted model
#' 
#' @aliases get.brokenstick.values
#' @param fit The fitted model of class \code{lmerMod}, presumably fitted
#'  by \code{fit.brokenstick()}
#' @return Matrix with broken stick values
#' @export
get.brokenstick.values <- function(fit) {
    if (!inherits(fit, "lmerMod")) stop("Argument 'fit' not of class lmerMod")
    return(t(t(ranef(fit)$id) + fixef(fit)))
}



#' Export the estimates of a fitted lmer() model
#' 
#' Exports the crucial estimates of a fitted lmer() model so that the 
#' stored estimates can be used by the EB() function 
#' to calculate random effect estimates for new user data.
#' 
#' @aliases export.brokenstick
#' @param model An object of class \code{lmerMod} or class 
#' \code{broken.stick.export} (typically generated 
#' by a previous call to \code{export.brokenstick()}).
#' @return A \code{list} of class \code{broken.stick.estimate}, with elements corresponding to the estimates parameters of the fitted model.
#' @export
export.brokenstick <- function(model) {
    
    # if already a broken.stick.export object, do nothing
    if (inherits(model, "broken.stick.export")) return(model)

    if (!inherits(model, "lmerMod")) 
        stop("Argument 'model' expected as class 'lmerMod' or 'broken.stick.export'")
    
    # extract estimates from merMod object
    beta <- fixef(model)
    omega <- as.matrix(as.data.frame(VarCorr(model)$id))  # variance of RE, Q*Q
    df <- as.data.frame(VarCorr(model))
    sigma2 <- df[df$grp == "Residual", "vcov"]
    
    z <- list(beta = beta, omega = omega, sigma2 = sigma2,
              knots = attr(model, "knots"), 
              Boundary.knots = attr(model, "Boundary.knots"))
    class(z) <- "broken.stick.export"
    return(z)
}

#' Empirical Bayes predictor for random effects
#' 
#' This function can estimate random effect for a given set of 
#' model estimates and new user data. Contrary to many current 
#' implementations for random effect prediction, the unit may be 
#' new to the model. The methods implements the 
#' EB estimate (also known as BLUP) 
#' as described in Skrondral and Rabe-Hasketh, 2009, p. 683. 
#' This function can also provide the broken stick estimate for a given level, 
#' which is simply the sum of (global) fixed and (level) random effects
#' The current implementation does not provide prediction errors.
#' 
#' @aliases EB
#' @param model An object of class \code{lmerMod} (typically created by
#' \code{fit.brokenstick()}) or class \code{broken.stick.export} 
#' (typically generated by \code{export.brokenstick()}).
#' @param y A vector of new measurements for unit j, scaled in the same metric as the fitted model.
#' @param X A \code{nj * p} matrix with fixed effects for unit j, typically produced by \code{make.basis()}.
#' @param Z A \code{nj * q} matrix with random effects for unit j. The default sets \code{Z} equal to \code{X}.
#' @param BS A logical indicating whether broken stick estimates should be
#' returned (\code{BS = TRUE}) or the random effects (\code{BS = FALSE}). 
#' The default is \code{FALSE}.
#' @return A vector of length q containing the random effect or broken stick  estimates for unit j.
#' @author Stef van Buuren, 2015
#' @references 
#' Skrondal, A., Rabe-Hesketh, S. (2009). 
#' Prediction in multilevel generalized linear models. 
#' J. R. Statist. Soc. A, 172, 3, 659-687.
#' @examples 
#' library(mice)
#' data <- tbc[tbc$id < 200 & tbc$age < 2.5,]
#' fit <- fit.brokenstick("hgt.z", data)
#' #
#' # conventional random effect for child id 8
#' ranef(fit)$id[1,]
#' #
#' # EB estimate random effect for child id 8
#' est <- export.brokenstick(fit)
#' y <- data[data$id == 8, "hgt.z"]
#' y
#' X <- make.basis(data[data$id == 8, "age"])
#' X
#' EB(est, y, X)
#' @export
EB <- function (model, y, X, Z = X, BS = FALSE) {
    
    # make sure we get the exported model
    export <- export.brokenstick(model)

    # eliminate missing outcomes 
    select <- !is.na(y)
    if (!any(select)) return(NULL)

    # get into shape for matrix multiplication
    y <- matrix(y[select], ncol = 1) # nj * 1
    Z <- as.matrix(Z[select,])  # nj * q
    X <- as.matrix(X[select,])  # nj * p
    beta <- matrix(export$beta, ncol = 1)
    
    # construct appropriate matrices
    sigma.inv <- solve(Z %*% export$omega %*% t(Z) + 
                           diag(export$sigma2, nrow(Z)))
    
    # calculate random effect by EB estimate
    re <- export$omega %*% t(Z) %*% sigma.inv %*% (y - X %*% beta)
    
    # calculate broken stick estimate by summing fixed and random parts
    if (BS) re <- export$beta + re
    
    return(as.vector(re))
}
